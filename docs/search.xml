<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>几种用SSH执行远程命令的方法（译）</title>
      <link href="/blog/2018/11/03/ssh-remote-command/"/>
      <url>/blog/2018/11/03/ssh-remote-command/</url>
      
        <content type="html"><![CDATA[<p>这篇文章将罗列几种使用SSH远程执行命令的方法。<br>假设 HOST 参数已经配置好了你的测试服务器信息。</p><h1 id="单行命令"><a href="#单行命令" class="headerlink" title="单行命令"></a>单行命令</h1><p>执行一个单行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="variable">$HOST</span> ls</span><br></pre></td></tr></table></figure><p>执行多个用;分割的内联命令 (inlined, separated with ;)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="variable">$HOST</span> ls; <span class="built_in">pwd</span>; cat /path/to/remote/file</span><br></pre></td></tr></table></figure><p>使用sudo权限执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="variable">$HOST</span> sudo ls /root</span><br><span class="line">sudo: no tty present and no askpass program specified</span><br></pre></td></tr></table></figure><p>sudo 需要与shell交互, 需要用 -t 参数开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -t <span class="variable">$HOST</span> sudo ls /root</span><br><span class="line">[sudo] password <span class="keyword">for</span> zaiste:</span><br></pre></td></tr></table></figure><h1 id="简单的多行命令"><a href="#简单的多行命令" class="headerlink" title="简单的多行命令"></a>简单的多行命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VAR1=<span class="string">"Variable 1"</span></span><br><span class="line">ssh <span class="variable">$HOST</span> <span class="string">'</span></span><br><span class="line"><span class="string">ls</span></span><br><span class="line"><span class="string">pwd</span></span><br><span class="line"><span class="string">if true; then</span></span><br><span class="line"><span class="string">    echo "True"</span></span><br><span class="line"><span class="string">    echo $VAR1      # &lt;-- it won'</span>t work</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"False"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><p>shell 变量$VAR1将不会传递到远程命令中</p><h1 id="可以带变量的多行远程命令"><a href="#可以带变量的多行远程命令" class="headerlink" title="可以带变量的多行远程命令"></a>可以带变量的多行远程命令</h1><p>为了能够传递变量，我们使用bash -c 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VAR1=<span class="string">"Variable 1"</span></span><br><span class="line">ssh <span class="variable">$HOST</span> bash -c <span class="string">"'</span></span><br><span class="line"><span class="string">ls</span></span><br><span class="line"><span class="string">pwd</span></span><br><span class="line"><span class="string">if true; then</span></span><br><span class="line"><span class="string">    echo <span class="variable">$VAR1</span></span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    echo "</span>False<span class="string">"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">'"</span></span><br></pre></td></tr></table></figure><h1 id="在远程机器上执行本地脚本"><a href="#在远程机器上执行本地脚本" class="headerlink" title="在远程机器上执行本地脚本"></a>在远程机器上执行本地脚本</h1><p>可以简单的用stdin重定向实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat script.sh</span><br><span class="line">ls</span><br><span class="line">pwd</span><br><span class="line">hostname</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="variable">$HOST</span> &lt; script.sh</span><br></pre></td></tr></table></figure><h1 id="使用Heredoc远程执行多行命令"><a href="#使用Heredoc远程执行多行命令" class="headerlink" title="使用Heredoc远程执行多行命令"></a>使用Heredoc远程执行多行命令</h1><p>使用<strong>heredoc</strong>可能是最方便的远程执行多行命令的方式了。<br>而且支持代码块外的变量传递。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VAR1=<span class="string">"boo"</span></span><br><span class="line">ssh -T <span class="variable">$HOST</span> &lt;&lt; EOSSH</span><br><span class="line">ls</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$VAR1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"False"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOSSH</span><br></pre></td></tr></table></figure><p>如果需要在heredoc代码块内定义变量，那就在heredoc开始的标记上打上单引号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssh -T <span class="variable">$HOST</span> &lt;&lt;<span class="string">'EOSSH'</span></span><br><span class="line">VAR1=`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR1</span></span><br><span class="line"></span><br><span class="line">VAR2=$(uname -a)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR2</span></span><br><span class="line"></span><br><span class="line">EOSSH</span><br></pre></td></tr></table></figure><p>如果出现以下的警告信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pseudo-terminal will not be allocated because stdin is not a terminal.</span><br></pre></td></tr></table></figure><p>可以执行ssh命令的时候加上 -T 参数消除这个警告</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://zaiste.net/a_few_ways_to_execute_commands_remotely_using_ssh/" target="_blank" rel="noopener">here</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> ssh </tag>
            
            <tag> remote </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC源码解析(一) - Http请求处理流程</title>
      <link href="/blog/2018/10/30/springmvc-resquest-flow/"/>
      <url>/blog/2018/10/30/springmvc-resquest-flow/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>我们在使用SpringMVC开发业务逻辑的时候，经常使用@Controller，@RequestMapping等注解快速注册并接收网络请求。<br>那今天我们来看一下，当接收到一个网络请求后，SpringMVC框架是如何找到你的业务逻辑代码处理请求，并返回结果的。</p><h1 id="2-核心类图及方法"><a href="#2-核心类图及方法" class="headerlink" title="2. 核心类图及方法"></a>2. 核心类图及方法</h1><p>SpringMVC处理请求的核心类是DispatcherServlet，我们先来看一下他的类图</p><img src="/blog/2018/10/30/springmvc-resquest-flow/springmvc_class.jpg" title="DispatcherServler类图"><p>我们看到核心类 DispacherServlet的祖先都是一些个抽象类。真正可以被实例化使用的只有DispatcherServlert，那关于处理请求方面，<br>这些抽象类都干了些什么呢？我们先来看一下定义了Servlet容器的接口<strong>javax.servlet.http.Servlet</strong>的源码</p><h1 id="2-1-Servlet接口-及-HttpServlet中的实现"><a href="#2-1-Servlet接口-及-HttpServlet中的实现" class="headerlink" title="2.1 Servlet接口 及 HttpServlet中的实现"></a>2.1 Servlet接口 及 HttpServlet中的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Servlet容器初始化接口，Servlet初始化后备调用。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回Servlet配置对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Servlet处理请求的接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回servlet的信息，例如作者，版本和copyright</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当Servlet被移出服务的时候被调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们主要关心的是处理请求的service方法，我们来看一下他在<strong>HttpServlet</strong>中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String method = req.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                <span class="comment">// Invalid date header - proceed as if none was set</span></span><br><span class="line">                ifModifiedSince = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见HttpServlet实现了service方法并根据Http请求的Method调用了doGet,doHead,doPost,doPut,doDelete,doOptions,doTrace等方法。那末，请求便根据requestMethod被分散到了不通的方法中处理。</p><h1 id="2-2-FrameworkServlet"><a href="#2-2-FrameworkServlet" class="headerlink" title="2.2 FrameworkServlet"></a>2.2 FrameworkServlet</h1><p>我们再来看一下DispatcherServlet的父类FrameworkServlet的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override the parent class implementation in order to intercept PATCH requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate GET requests to processRequest/doService.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Will also be invoked by HttpServlet's default implementation of &#123;<span class="doctag">@code</span> doHead&#125;,</span></span><br><span class="line"><span class="comment"> * with a &#123;<span class="doctag">@code</span> NoBodyResponse&#125; that just captures the content length.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doHead</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate POST requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate PUT requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate DELETE requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate OPTIONS requests to &#123;<span class="doctag">@link</span> #processRequest&#125;, if desired.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Applies HttpServlet's standard OPTIONS processing otherwise,</span></span><br><span class="line"><span class="comment"> * and also if there is still no 'Allow' header set after dispatching.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOptions</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="keyword">if</span> (response.containsHeader(<span class="string">"Allow"</span>)) &#123;</span><br><span class="line"><span class="comment">// Proper OPTIONS response coming from a handler - we're done.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use response wrapper in order to always add PATCH to the allowed methods</span></span><br><span class="line"><span class="keyword">super</span>.doOptions(request, <span class="keyword">new</span> HttpServletResponseWrapper(response) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"Allow"</span>.equals(name)) &#123;</span><br><span class="line">value = (StringUtils.hasLength(value) ? value + <span class="string">", "</span> : <span class="string">""</span>) + HttpMethod.PATCH.name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">super</span>.setHeader(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate TRACE requests to &#123;<span class="doctag">@link</span> #processRequest&#125;, if desired.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Applies HttpServlet's standard TRACE processing otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTrace</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.dispatchTraceRequest) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"message/http"</span>.equals(response.getContentType())) &#123;</span><br><span class="line"><span class="comment">// Proper TRACE response coming from a handler - we're done.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">super</span>.doTrace(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process this request, publishing an event regardless of the outcome.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The actual event handling is performed by the abstract</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #doService&#125; template method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line">initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doService(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line"><span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">requestAttributes.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (failureCause != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Could not complete request"</span>, failureCause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Leaving response open for concurrent processing"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Successfully completed request"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameworkServlet做了以下几件事情:</p><ol><li>覆写doGet,doPost,doPut等方法，都调用了processRequest来处理请求，把父类HttpServlet分散到各个方法中处理的请求又归拢到了一起，使用processRequest集中处理。</li><li>覆写service方法，支持了http PATCH方法。</li><li>processRequest方法初始化了ContextHolder并调用了抽象方法<strong>doService</strong>处理请求。</li><li>publish了请求已被处理的ApplicationEvent。</li></ol><h1 id="2-3-DispatcherServlet"><a href="#2-3-DispatcherServlet" class="headerlink" title="2.3 DispatcherServlet"></a>2.3 DispatcherServlet</h1><p>DispacherServlet 实现了父类的抽象方法doService。先做了一些准备工作，便调用了doDispatch处理请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;<span class="doctag">@link</span> #doDispatch&#125;</span></span><br><span class="line"><span class="comment"> * for the actual dispatching.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">" resumed"</span> : <span class="string">""</span>;</span><br><span class="line">logger.debug(<span class="string">"DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span> + resumed +</span><br><span class="line"><span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line"><span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line"><span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">String attrName = (String) attrNames.nextElement();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doDispatch(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line"><span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DispacherServlet 的 doDispatch方法是SpringMVC处理请求的核心方法，我们来看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order.</span></span><br><span class="line"><span class="comment"> * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters</span></span><br><span class="line"><span class="comment"> * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment"> * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理步骤：</p><ol><li>获取请求对应的 HandlerExecutionChain，HandlerExecution中的handler记录了业务代码的入口方法。</li><li>获取该 HandlerExecutionChain 中 handler对应的handlerAdapter</li><li>执行 HandlerExecutionChain中拦截器的preHandler方法。</li><li>执行 hander,获得ModelAndView对象mv</li><li>执行 HandlerExecutionChain中拦截器的postHandler方法。</li><li>执行 postDispatchResult方法，如果mv!=null,渲染视图。</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>整个请求的处理流程的时序图如下：</p><img src="/blog/2018/10/30/springmvc-resquest-flow/DispatcherServletSequence.jpg" title="SpringMVC请求处理总时序图">]]></content>
      
      
      <categories>
          
          <category> spring源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> springMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用git credential免密认证git http仓库</title>
      <link href="/blog/2018/10/29/git-credential/"/>
      <url>/blog/2018/10/29/git-credential/</url>
      
        <content type="html"><![CDATA[<h1 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h1><p>在git仓库目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.name xxx</span><br><span class="line">git config user.email xxx@xxx.com</span><br><span class="line">git config credential.helper store</span><br></pre></td></tr></table></figure><h1 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h1><p>密码将会以明文形式存储在~/.git-credentials文件中，不安全。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> command </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用ApplicationContextAware制作一个获取ApplicationContext的Provider</title>
      <link href="/blog/2018/10/26/use-of-application-context-aware/"/>
      <url>/blog/2018/10/26/use-of-application-context-aware/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义一个继承-ApplicationContextAware-的-bean"><a href="#1-定义一个继承-ApplicationContextAware-的-bean" class="headerlink" title="1. 定义一个继承 ApplicationContextAware 的 bean"></a>1. 定义一个继承 ApplicationContextAware 的 bean</h1><p>定义一个类ApplicationContextProvider，继承ApplicationContextAware,并用@Component注册一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextProvider</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseSample</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autoware</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationContextProvider applicationContextProvider;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext appctx = applicationContextProvider.getContext();</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h1><p>spirng初始化的bean时，将会查看这个bean是否实现了ApplicationContextAware接口。如果是，将会调用<br>setApplicationContext()方法。我们在ApplicationContextProvider在实现把AppContext的地址保存到了私有变量中。</p><p>spring源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line"> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">  ((ApplicationContextAware)bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bean </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义HandlerMethodArgumentResolver，用Cookie组装一个简单的Pojo对象</title>
      <link href="/blog/2018/10/24/custom-handler-method-argument-resolver/"/>
      <url>/blog/2018/10/24/custom-handler-method-argument-resolver/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>SpringMVC为我们提供了@CookieValue来注入cookie某一个key的值，但我们常需要@RequestBody一样，把Cookie组装成一个pojo对象。<br>这篇教程将会演示我们怎样自定义一个HandlerMethodArgumentResolver完成从Cookie组装pojo对象的需求。</p><h1 id="2-自定义HandlerMethodArgumentResolver"><a href="#2-自定义HandlerMethodArgumentResolver" class="headerlink" title="2. 自定义HandlerMethodArgumentResolver"></a>2. 自定义HandlerMethodArgumentResolver</h1><h1 id="2-1-定义Annotation"><a href="#2-1-定义Annotation" class="headerlink" title="2.1 定义Annotation"></a>2.1 定义Annotation</h1><p>我们先定义一个Annotation，叫CookieObject。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CookieObject &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-2-实现HandlerMethodArgumentResolver接口"><a href="#2-2-实现HandlerMethodArgumentResolver接口" class="headerlink" title="2.2 实现HandlerMethodArgumentResolver接口"></a>2.2 实现HandlerMethodArgumentResolver接口</h1><p>再定义个CookieObjectMethodArgumentResolver类，实现HandlerMethodArgumentResolver接口<br>HandlerMethodArgumentResolver有两个method.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br></pre></td></tr></table></figure><p>返回true/false,表示resolver是否支持处理该参数，我们将在他的实现里，判断参数是否携带@CookieObject.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>组装参数的实现逻辑。</p><p>来，让我们看一下具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieObjectMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String defaultEncoding = WebUtils.DEFAULT_CHARACTER_ENCODING;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">decodeInternal</span><span class="params">(HttpServletRequest request, String source)</span> </span>&#123;</span><br><span class="line">        String enc = determineEncoding(request);</span><br><span class="line">        <span class="keyword">return</span> UriUtils.decode(source, enc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineEncoding</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String enc = request.getCharacterEncoding();</span><br><span class="line">        <span class="keyword">if</span> (enc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            enc = <span class="keyword">this</span>.defaultEncoding;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parameter.hasParameterAnnotation(CookieObject.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"></span><br><span class="line">        Class clazz = parameter.getParameterType();</span><br><span class="line"></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Cookie[] cookies = servletRequest.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass());</span><br><span class="line">            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor property : propertyDescriptors) &#123;</span><br><span class="line">                Method setter = property.getWriteMethod();</span><br><span class="line">                Class ppClazz = property.getPropertyType();</span><br><span class="line">                <span class="keyword">if</span> (setter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String propName = property.getName();</span><br><span class="line">                    Cookie cooike = WebUtils.getCookie(servletRequest, propName);</span><br><span class="line">                    <span class="keyword">if</span> (cooike != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        String cookieValue = decodeInternal(servletRequest, cooike.getValue());</span><br><span class="line">                        Object setValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (Cookie.class.isAssignableFrom(ppClazz)) &#123;</span><br><span class="line">                            setValue = cookieValue;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cookieValue != <span class="keyword">null</span> &amp;&amp; binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            WebDataBinder binder = binderFactory.createBinder(webRequest, <span class="keyword">null</span>, propName);</span><br><span class="line">                            setValue = binder.convertIfNecessary(cookieValue, ppClazz);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (setValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            setter.invoke(obj, setValue);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-3-加入argumentResolvers列表"><a href="#2-3-加入argumentResolvers列表" class="headerlink" title="2.3 加入argumentResolvers列表"></a>2.3 加入argumentResolvers列表</h1><p>最后再SpringMVC的配置中把我们定义的CookieObjectMethodArgumentResolver实例化后加入argumentResolvers列表。</p><p><code></code>java<br>@Configuration<br>public class WebConfig extends WebMvcConfigurationSupport {<br>    @Override<br>    protected void addArgumentResolvers(List<handlermethodargumentresolver> argumentResolvers) {<br>        CookieObjectMethodArgumentResolver cookieObjectMethodArgumentResolver = new CookieObjectMethodArgumentResolver()<br>        argumentResolvers.add(cookieObjectMethodArgumentResolver());<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 3. 使用</span><br><span class="line"></span><br><span class="line"># 3.1 定义一个pojo</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Data</span><br><span class="line">@JsonIgnoreProperties(ignoreUnknown = true)</span><br><span class="line">@EqualsAndHashCode(callSuper = false)</span><br><span class="line">public class MyCookieParam  &#123;</span><br><span class="line">    private String foo;</span><br><span class="line">    private String bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></handlermethodargumentresolver></p><h1 id="3-2-在Controller中接收"><a href="#3-2-在Controller中接收" class="headerlink" title="3.2 在Controller中接收"></a>3.2 在Controller中接收</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testCookieObject"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testCookieObject</span><span class="params">(@CookieObject MyCookieParam cookieParam)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cookieParam</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> handlerMethodResolver </tag>
            
            <tag> springMvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring自定义Scope (译)</title>
      <link href="/blog/2018/10/24/spring-custom-scope/"/>
      <url>/blog/2018/10/24/spring-custom-scope/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>开箱即用的spring boot提供了”singleton”和”prototype”2个标准的，可以在任何spring application中使用的bean scope，<br>以及”request”,”session”,”globalSession” 3个附加的，只能在web-aware application中使用的bean scope。</p><p>标准的bean scope 不能被overridden ,web-aware application虽然可以被overiddde，可是常会带来不好的结果，所以不建议去改写。但我们也常常会遇到一些需求是预提供的bean scope满足不了的，需要额外的功能。</p><p>比如，需要开发一个multi-tenant(多租户)系统，你需要为每一个tenant提供一组隔离的bean。spring为了支持这类需求，提供了创建自定义Scope的机制。</p><p>在这篇教程中，将阐述怎样在spring中 <strong>创建,注册,使用</strong> 自定义bean scope。</p><h1 id="2-创建一个自定义Scope类"><a href="#2-创建一个自定义Scope类" class="headerlink" title="2. 创建一个自定义Scope类"></a>2. 创建一个自定义Scope类</h1><p>为了创建一个自定义类，我们需要implement Scope Interface,<br>并且因为会被并发调用，必须确保这个实现是进程安全(thread safe)的。</p><h1 id="2-1-管理-Scope-Object-Callback"><a href="#2-1-管理-Scope-Object-Callback" class="headerlink" title="2.1 管理 Scope Object Callback"></a>2.1 管理 Scope Object Callback</h1><p>实现自定义Scope首先要考虑怎样存储和管理scoped object 已经 destuction callbacks。我们可以使用map或专用的类。<br>举个例子，本教程使用了线程安全的 synchronized maps.<br>让我们开始定义我们的scope类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenantScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; scopedObjects</span><br><span class="line">      = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Object&gt;());</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Runnable&gt; destructionCallbacks</span><br><span class="line">      = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Runnable&gt;());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-2-从Scope中获取Object"><a href="#2-2-从Scope中获取Object" class="headerlink" title="2.2 从Scope中获取Object"></a>2.2 从Scope中获取Object</h1><p>为了用name从Scope获取Object，我们需要实现getObject方法，<strong>如果取不到Object，我们必须新建一个Object并返回它</strong></p><p>在我们的实现中，我们先检查是否能从我们的map中取到Object，如果取到了返回它，如果没取到，我们使用ObjectFactory创建一个新的Object，把它添加到map中并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!scopedObjects.containsKey(name)) &#123;</span><br><span class="line">        scopedObjects.put(name, objectFactory.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scopedObjects.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Scope接口中定义的5个方法中，<strong>只有get方法是必须要实现的</strong>，其他4个方法的实现是可选的，当没有实现却被调用的情况下会抛出UnsupportedOperationException异常。</p><h1 id="2-3-实现销毁回调（Destruction-Callback）"><a href="#2-3-实现销毁回调（Destruction-Callback）" class="headerlink" title="2.3 实现销毁回调（Destruction Callback）"></a>2.3 实现销毁回调（Destruction Callback）</h1><p>我们必须实现registerDestructionCallback方法，这个方法提供了当object或scope本身被销毁的时候的回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;</span><br><span class="line">    destructionCallbacks.put(name, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-4-从Scope移除Object"><a href="#2-4-从Scope移除Object" class="headerlink" title="2.4 从Scope移除Object"></a>2.4 从Scope移除Object</h1><p>接下来，让我们实习那remove方法。remove方法从scope删除了object，移除了之前注册的销毁时的回调，并且返回被移除的object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    destructionCallbacks.remove(name);</span><br><span class="line">    <span class="keyword">return</span> scopedObjects.remove(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： <strong>是调用此方法的caller去真正的执行callback并销毁被移除的object</strong></p><h1 id="2-5-获取Conversation-ID"><a href="#2-5-获取Conversation-ID" class="headerlink" title="2.5 获取Conversation ID"></a>2.5 获取Conversation ID</h1><p>现在，让我们实现getConversationId方法，如果你的scope支持conversation ID的概念,<br>你可以在这里返回，如果不支持，返回null就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getConversationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"tenant"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-6-Resolving-Contextual-Objects"><a href="#2-6-Resolving-Contextual-Objects" class="headerlink" title="2.6 Resolving Contextual Objects"></a>2.6 Resolving Contextual Objects</h1><p>最后，让我们实现resolveContextualObject,如果你的Scope支持多个contextual object，你需要用键值对关联每个object,并返回调用参数key所对应的object。<br>如果不支持，返回null就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveContextualObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-注册自定义Scope"><a href="#3-注册自定义Scope" class="headerlink" title="3. 注册自定义Scope"></a>3. 注册自定义Scope</h1><p>为了让spring容器意识到你的新Scope，<strong>我们需要调用ConfigurableBeanFactory实例的register方法中注册新Scope</strong>. 我们来看一个这个方法的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerScope</span><span class="params">(String scopeName, Scope scope)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数scopeName是用来定义scope的唯一键，第二个参数scope是是你想要注册使用的自定义Scope的实例。</p><p>让我们创建一个自定义一个BeanFactoryPostProcessor，然后使用ConfigurableListableBeanFactory注册自定义scope</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenantBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory factory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        factory.registerScope(<span class="string">"tenant"</span>, <span class="keyword">new</span> TenantScope());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们写一个Spring configuration类加载我们的 BeanFactoryPostProcessor实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenantScopeConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactoryPostProcessor <span class="title">beanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TenantBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-使用自定义Scope"><a href="#4-使用自定义Scope" class="headerlink" title="4. 使用自定义Scope"></a>4. 使用自定义Scope</h1><p>至此，我们已经注册了自定义scope，我们可以像使用任何scope一样使用我们的自定义scope。</p><p>先让我们定义一个TenantBean类，我们将会使用tenant-scope注入它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenantBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TenantBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">          String.format(<span class="string">"Hello from %s of type %s"</span>,</span><br><span class="line">          <span class="keyword">this</span>.name,</span><br><span class="line">          <span class="keyword">this</span>.getClass().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们在这个类上没有使用类级别的@Component和@Scope注解。现在我们在configuration类中定义tenant-scoped beans</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenantBeansConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scope</span>(scopeName = <span class="string">"tenant"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TenantBean <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TenantBean(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scope</span>(scopeName = <span class="string">"tenant"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TenantBean <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TenantBean(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-测试自定义Scope"><a href="#5-测试自定义Scope" class="headerlink" title="5. 测试自定义Scope"></a>5. 测试自定义Scope</h1><p>让我们写一些单元测试测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">whenRegisterScopeAndBeans_thenContextContainsFooAndBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ctx.register(TenantScopeConfig.class);</span><br><span class="line">        ctx.register(TenantBeansConfig.class);</span><br><span class="line">        ctx.refresh();</span><br><span class="line"></span><br><span class="line">        TenantBean foo = (TenantBean) ctx.getBean(<span class="string">"foo"</span>, TenantBean.class);</span><br><span class="line">        foo.sayHello();</span><br><span class="line">        TenantBean bar = (TenantBean) ctx.getBean(<span class="string">"bar"</span>, TenantBean.class);</span><br><span class="line">        bar.sayHello();</span><br><span class="line">        Map&lt;String, TenantBean&gt; foos = ctx.getBeansOfType(TenantBean.class);</span><br><span class="line"></span><br><span class="line">        assertThat(foo, not(equalTo(bar)));</span><br><span class="line">        assertThat(foos.size(), equalTo(<span class="number">2</span>));</span><br><span class="line">        assertTrue(foos.containsValue(foo));</span><br><span class="line">        assertTrue(foos.containsValue(bar));</span><br><span class="line"></span><br><span class="line">        BeanDefinition fooDefinition = ctx.getBeanDefinition(<span class="string">"foo"</span>);</span><br><span class="line">        BeanDefinition barDefinition = ctx.getBeanDefinition(<span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line">        assertThat(fooDefinition.getScope(), equalTo(<span class="string">"tenant"</span>));</span><br><span class="line">        assertThat(barDefinition.getScope(), equalTo(<span class="string">"tenant"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello from foo of type org.baeldung.customscope.TenantBean</span><br><span class="line">Hello from bar of type org.baeldung.customscope.TenantBean</span><br></pre></td></tr></table></figure><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>在本教程中我们演示了spring怎样定义，注册和使用自定义scope。你可以通过阅读<br><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/#beans-factory-scopes-custom" target="_blank" rel="noopener">Spring Framework Reference</a>了解更多细节，你也可以通过<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">Spring Framework</a>源码.看一下Spring是如何实现了各种Scope.</p><p>你可以<a href="https://github.com/eugenp/tutorials/tree/master/spring-all" target="_blank" rel="noopener">点这里</a>获取本教程代码</p><p><strong><a href="https://www.baeldung.com/spring-custom-scope" target="_blank" rel="noopener">原文链接</a></strong> : <a href="https://www.baeldung.com/spring-custom-scope" target="_blank" rel="noopener">https://www.baeldung.com/spring-custom-scope</a></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> scope </tag>
            
            <tag> java </tag>
            
            <tag> 译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用bash制作守护进程的脚本</title>
      <link href="/blog/2018/10/23/bash-process-watcher/"/>
      <url>/blog/2018/10/23/bash-process-watcher/</url>
      
        <content type="html"><![CDATA[<h1 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h1><p>在linux deploy服务时，为了保证服务crash以后能够自动重启，经常需要制作守护进程的脚本。</p><h2 id="1-记录进程的PID"><a href="#1-记录进程的PID" class="headerlink" title="1. 记录进程的PID"></a>1. 记录进程的PID</h2><p>为了得到准确的进程PID，我们经常在启动脚本中输出一个xxx.pid文件，其中记录了需要守护的进程的PID</p><p>我们可以利用bash变量!\$ 获取Shell最后运行的后台Process的PID</p><p>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">java -jar myapp.jar &amp; <span class="built_in">echo</span> $! &gt; ./pid.file &amp;</span><br></pre></td></tr></table></figure><p>这样我们便得到了 myapp.jar的进程PID,并写入了 ./pid.file文件中</p><h2 id="2-监测进程是否在运行"><a href="#2-监测进程是否在运行" class="headerlink" title="2. 监测进程是否在运行"></a>2. 监测进程是否在运行</h2><p>利用 kill -0 检测进程是否存在<br>kill -0 \$pid中的-0表示不发送任何信号给PID对应的进程，但是仍会对变量值PID对应的进程是否存在进行检查，如果\$pid对应的进程存在，则返回0，不存在返回1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PID=$(cat ./pid.file) &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="built_in">kill</span> -0 <span class="variable">$&#123;SAUNA_PID&#125;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">IS_RUNNING=$?</span><br></pre></td></tr></table></figure><h2 id="3-完整脚本"><a href="#3-完整脚本" class="headerlink" title="3. 完整脚本"></a>3. 完整脚本</h2><p>start.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PID_FILE=<span class="variable">$&#123;HOME&#125;</span>/pids/app.pid</span><br><span class="line">WATCH_PID_FILE=<span class="variable">$&#123;HOME&#125;</span>/pids/watch.pid</span><br><span class="line"></span><br><span class="line"><span class="comment">#进程PID输出到文件</span></span><br><span class="line">java -jar myapp.jar &amp; <span class="built_in">echo</span> $! &gt; <span class="variable">$&#123;PID_FILE&#125;</span> 2&gt;/dev/null &amp;</span><br><span class="line">sleep 5</span><br><span class="line"></span><br><span class="line">sh watch.sh &gt; watch.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $! &gt; <span class="variable">$&#123;PID_FILE&#125;</span></span><br></pre></td></tr></table></figure><p>watch.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PID_FILE=<span class="variable">$&#123;HOME&#125;</span>/pids/app.pid</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$PID_FILE</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment">#如果PID文件存在</span></span><br><span class="line">  PID=$(cat <span class="variable">$&#123;SAUNA_PID_FILE&#125;</span>) &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  <span class="built_in">kill</span> -0 <span class="variable">$&#123;PID&#125;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  IS_RUNNING=$?</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  PID=<span class="string">"0000"</span></span><br><span class="line">  IS_RUNNING=1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检测循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 5 秒检测一次</span></span><br><span class="line">  sleep 5</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$&#123;IS_RUNNING&#125;</span> -ne 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"service is dead. restarting..."</span>;</span><br><span class="line">    sh start.sh</span><br><span class="line">    <span class="built_in">exit</span> 0;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">kill</span> -0 <span class="variable">$&#123;PID&#125;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  IS_RUNNING=$?</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> stop脚本里要kill掉watch.sh ，不然会重复启动。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ElasticSearch服务器secrity配置</title>
      <link href="/blog/2018/10/23/es-server-config/"/>
      <url>/blog/2018/10/23/es-server-config/</url>
      
        <content type="html"><![CDATA[<h1 id="1-修改-etc-security-limits-conf"><a href="#1-修改-etc-security-limits-conf" class="headerlink" title="1. 修改/etc/security/limits.conf"></a>1. 修改/etc/security/limits.conf</h1><p>/etc/security/limits.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[username] soft nofile 102400</span><br><span class="line">[username] hard nofile 102400</span><br><span class="line">[username] soft nproc 2048</span><br><span class="line">[username] hard nproc 2048</span><br><span class="line">[username] soft memlock unlimited</span><br><span class="line">[username] hard memlock unlimited</span><br></pre></td></tr></table></figure><p>重新登录后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a 检测</span><br></pre></td></tr></table></figure><h1 id="2-修改max-map-count"><a href="#2-修改max-map-count" class="headerlink" title="2. 修改max_map_count"></a>2. 修改max_map_count</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure><p>执行命令刷新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux中shell变量$#,$@,$0,$1,$2的含义解释</title>
      <link href="/blog/2018/10/23/bash-args/"/>
      <url>/blog/2018/10/23/bash-args/</url>
      
        <content type="html"><![CDATA[<p>变量说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">Shell本身的PID（ProcessID）</span><br><span class="line">$!</span><br><span class="line">Shell最后运行的后台Process的PID</span><br><span class="line">$?</span><br><span class="line">最后运行的命令的结束代码（返回值）</span><br><span class="line">$-</span><br><span class="line">使用Set命令设定的Flag一览</span><br><span class="line">$*</span><br><span class="line">所有参数列表。如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。</span><br><span class="line">$@</span><br><span class="line">所有参数列表。如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。</span><br><span class="line">$#</span><br><span class="line">添加到Shell的参数个数</span><br><span class="line">$0</span><br><span class="line">Shell本身的文件名</span><br><span class="line">$1～$n</span><br><span class="line">添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> args </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux硬盘分区格式化以及挂载</title>
      <link href="/blog/2018/10/23/linux-mount-harddisk/"/>
      <url>/blog/2018/10/23/linux-mount-harddisk/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分区"><a href="#1-分区" class="headerlink" title="1. 分区"></a>1. 分区</h1><h2 id="1-1-使用fdisk"><a href="#1-1-使用fdisk" class="headerlink" title="1.1 使用fdisk"></a>1.1 使用fdisk</h2><p>1）先查看下是否有磁盘没有分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>2） 分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>3）根据提示操作</p><h3 id="1-2-使用-parted"><a href="#1-2-使用-parted" class="headerlink" title="1.2 使用 parted"></a>1.2 使用 parted</h3><h2 id="2-格式化新硬盘"><a href="#2-格式化新硬盘" class="headerlink" title="2. 格式化新硬盘"></a>2. 格式化新硬盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdb1</span><br></pre></td></tr></table></figure><h2 id="3-挂载"><a href="#3-挂载" class="headerlink" title="3. 挂载"></a>3. 挂载</h2><p>1) 创建/data目录（/data目录为硬盘将挂载的地方）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data</span><br></pre></td></tr></table></figure><p>2）挂载分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /data</span><br></pre></td></tr></table></figure><h2 id="4-查看磁盘分区的UUID"><a href="#4-查看磁盘分区的UUID" class="headerlink" title="4. 查看磁盘分区的UUID"></a>4. 查看磁盘分区的UUID</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ sudo blkid</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1: UUID=<span class="string">"8048997a-16c9-447b-a209-82e4d380326e"</span> TYPE=<span class="string">"ext4"</span></span><br><span class="line">/dev/sda5: UUID=<span class="string">"0c5f073a-ad3f-414f-85c2-4af83f6a437f"</span> TYPE=<span class="string">"swap"</span></span><br><span class="line">/dev/sdb1: UUID=<span class="string">"11263962-9715-473f-9421-0b604e895aaa"</span> TYPE=<span class="string">"ext4"</span></span><br><span class="line">/dev/sr0: LABEL=<span class="string">"Join Me"</span> TYPE=<span class="string">"iso9660"</span></span><br></pre></td></tr></table></figure><h2 id="5-配置开机自动挂载："><a href="#5-配置开机自动挂载：" class="headerlink" title="5. 配置开机自动挂载："></a>5. 配置开机自动挂载：</h2><p>因为mount命令会在重启服务器后失效，所以要将分区信息写到/etc/fstab文件中让它永久挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure><p>加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=11263962-9715-473f-9421-0b604e895aaa /data ext4 defaults 0 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">&lt;fs spec&gt; &lt;fs file&gt; &lt;fs vfstype&gt; &lt;fs mntops&gt; &lt;fs freq&gt; &lt;fs passno&gt;</span><br><span class="line">具体说明，以挂载/dev/sdb1为例:</span><br><span class="line">&lt;fs spec&gt; :</span><br><span class="line">分区定位，可以给UUID或LABEL，例如：UUID=6E9ADAC29ADA85CD或LABEL=software</span><br><span class="line">&lt;fs file&gt; : 具体挂载点的位置，例如：/data</span><br><span class="line">&lt;fs vfstype&gt; : 挂载磁盘类型，linux分区一般为ext4，windows分区一般为ntfs</span><br><span class="line">&lt;fs mntops&gt; : 挂载参数，一般为defaults</span><br><span class="line">&lt;fs freq&gt; : 磁盘检查，默认为0</span><br><span class="line">&lt;fs passno&gt; : 磁盘检查，默认为0,不需要检查</span><br></pre></td></tr></table></figure><p>修改完/etc/fstab文件后，运行sudo mount -a命令验证一下配置是否正确。如果配置不正确可能会导致系统无法正常启动。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> harddisk </tag>
            
            <tag> linux </tag>
            
            <tag> mount </tag>
            
            <tag> format </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rsync简易使用方法</title>
      <link href="/blog/2018/10/23/rsync/"/>
      <url>/blog/2018/10/23/rsync/</url>
      
        <content type="html"><![CDATA[<h1 id="rsync命令-Linux-rsync-命令"><a href="#rsync命令-Linux-rsync-命令" class="headerlink" title="rsync命令_Linux rsync 命令"></a>rsync命令_Linux rsync 命令</h1><hr><p>rsync是能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量。rsync中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> rsync -avp /data/deploy/opt/data_bk/ /data/deploy/opt/data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非标ssh端口</span></span><br><span class="line"> rsync -avp -e <span class="string">"ssh -p 2245"</span> /usr/sqmall/ root@brain-001:/usr/sqmall/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> command </tag>
            
            <tag> sync </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
